{"categories":[{"title":"Kỹ thuật","uri":"https://www.lhsang.me/categories/k%E1%BB%B9-thu%E1%BA%ADt/"},{"title":"Trải nghiệm","uri":"https://www.lhsang.me/categories/tr%E1%BA%A3i-nghi%E1%BB%87m/"}],"posts":[{"content":"Từ ghế học đường bước vào môi trường doanh nghiệp là một sự thay đổi không hề nhẹ về thói quen, cách làm việc và kể cả kiến thức mình đã được học. Những thứ trong trường chỉ là những thứ rất cơ bản, chưa đủ đáp ứng cho công việc công ty. Mặc dù làm một trang web, mobile application hay một desktop application hoàn chỉnh thì mình cũng đủ sức để làm ra, nhưng vấn đề tại sao vẫn chưa đáp ứng được cho môi trường doanh nghiệp?\n Thói quen code chỉ để cho chạy: code cho chạy không quan tâm đến performance bởi vì application mình code thì chỉ đâu đó mình dùng và bạn bè test qua thì dữ liệu rồi tải lượng cũng không đáng kể để mình chưa thấy được vấn đề performance quan trọng như thế nào. Hơn nữa, khi đọc docs thì cũng hay đọc những thứ mình cần tức thì chứ không quan tâm xung quanh, hoạt động như nào và sâu xuống có gì, làm theo =\u0026gt; code chạy =\u0026gt; xong :v Chưa có tầm nhìn để mở rộng: thường thì đồ án trong trường thì mình cũng như nhiều bạn sẽ code sao cho nhanh cho dễ cho mình thời điểm đó vì đồ án chỉ chấm xong là \u0026ldquo;vứt\u0026rdquo;, chứ đâu cần mở rộng. Vẫn nghĩ rằng nếu muốn mở rộng một chức năng tương tự thì chỉ cần copy ra sửa một chút là xong. Nhưng giờ nhìn lại hơi \u0026ldquo;vô học\u0026rdquo; khi chúng ta đã được học rất nhiều kiến trúc, kỹ thuật để lập trình và cả lập trình hướng đối tượng. Thói quen code mình mình đọc: code mọi thứ riêng biệt, tổ chức thư mục chưa tối ưu theo một pattern nào, gán cứng nhiều giá trị trong code hay đặt tên biến không nhất quán, code liên tiếp một đoạn dài ko phân cách nhóm code ra vì nghĩ mình có thể control được. Có thể là thời điểm đó là đúng với điều mình nghĩ, nhưng sau này thì mình không chắc là mình có thể đọc lại đống code mà chính mình viết ra. Sợ sai sợ bị chửi: thực tập sinh mà, khi bước vào công ty có lẻ rằng mình là nhỏ tuổi non kinh nghiệm nhất rồi, nên khi hỏi hay bày tỏ quan điểm thường cân nhắc rất kĩ trước là có nên nói ra vì chưa tự tin vào ý kiến, quan điểm của mình nên nhiều lúc thôi nghĩ im trất cho lành :v hoặc đi hỏi riêng một bạn cùng cấp cho đỡ nhục đỡ bị chửi thay vì bày tỏ quan điểm trước những buổi họp, daily meeting trước team.  Và còn rất nhiều vấn đề nhỏ nhặt khác, tuy nhiên nhiêu đó đã đủ ảnh hưởng nhiều đến công việc của mình, của team rồi và của công ty rồi. Sau một kỳ thực tập vài tháng thì mình mới nhìn nhận được những thói quen như vậy và đã được rèn luyện để tốt hơn ở đây. Kiến thức là cái quan trọng, tuy nhiên kiến thức rộng thôi chưa đủ, phải đủ sâu và phải đủ tầm. Nên những điều nhỏ nhặt này mình cho rằng rất quan trọng để mình tối ưu và hoàn thiện bản thân hơn. Nên mình sẽ chia sẻ nhẹ vài điều mình thu được từ kỳ thực tập ngắn ngủi theo hệ quy chiếu của mình.\n  Thói quen đọc document tốt hơn khi thường xuyên được giao nhiệm vụ research liên quan đến tech stack của công ty và thậm chí những vấn đề mới để sharing lại cho team. Khác với trước, khi đọc docs thì mình đọc mình biết thì bấy giờ mình đọc để làm việc cho công ty và đương nhiên khi được review code thậm chí thỉnh thoảng lại bị hỏi ngang, không biết sẽ bị ăn chửi ngay. Nhưng nhờ ăn chửi mà mình lại phải đọc thật kỹ trước khi đặt tay vào cào phím.Sharing chỉ đơn giản là một lời chia sẻ ngắn trong buổi daily meeting hay buổi thuyết trình cũng vậy, khi nói cho người khác nghe thì đâu đó tâm lý buộc mình phải chắc chắn về lời mình nói ra.Học lém được thói quen đọc code ngay từ trong core lib/framework. Trước giờ khi không biết lib/framework này có hàm gì, nhận tham số gì và hoạt động như nào thì toàn lên google để tìm vì cho rằng code trong core thường rối, nhưng không, các thư viện/framework thường được ghi chú và code rất rõ ràng (đôi lúc mình còn thấy ghi chú, giải thích code còn nhiều gấp 10 lần số lượng dòng code) và docs trên các trang web đó cũng thưuòng lấy từ đây ra cả ấy mà :v. Đọc code trong core là cách mình thấy học được rất nhiều: lib đó có những thuộc tính nào, hàm nào, hoạt động như thế nào và hơn nữa là học được phong cách tổ chức code theo mình là thấy khá chuẩn và tối ưu. (Nhưng cũng tùy ngôn ngữ, các ngôn ngữ bậc thấp như C thì mình cùng công nhận rằng code nhìn vào hơi loạn :'( )\n  Code làm sao cho tối ưu vì dữ liệu doanh nghiệp không phải vài ngàn records như đồ án mình làm, code \u0026ldquo;dỏm\u0026rdquo; chỉ cần đưa lên môi trường staging là chậm ngó thấy ngay. Nhưng trước khi đưa lên các môi trường thì phải trải qua 1,2 lần review code từ các anh senior. Đặt tên biến, gán cứng giá trị trong code, hay code một lều không phân đoạn để một đống thì ăn chửi là điều đương nhiên, code đâu phải mình mày đọc và mày với tao đâu phải làm việc đây suốt đời mà còn lớp khác vào nữa, sau vài tháng ăn chửi sẽ khiến mình tốt hơn, có lúc bị chửi đến mức tự ái nhưng giờ nhìn lại phải biết ơn những câu chửi đó ^^\n  Để join và làm được task trong project thì mình cũng thường được cho thời gian để đọc full project. Một project không hề nhỏ, code người khác viết, mình thì mới biết cơ bản làm sao hiểu được luồng đi của ứng dụng? Đâu đó được chỉ debug để nắm luồng chạy của ứng dụng - một cách mà mình chưa từng làm trước đây (vì thường đọc code của chính mình viết hoặc bạn viết thì hỏi bạn :)) Khá khoai nhưng rất lợi hại, đỡ phải chạy hỏi cùng với sự bỡ ngỡ vì chính mình có thể thấy được luồng chạy. Quá trình đọc project thì mình cũng để ý cách tổ chức thư mục cũng như các class rất khoa học (khoa học sẽ tốn thời gian hơn, nhưng mở rộng và maintain rất tiện và nhanh chóng). Và được bonus thêm những lời giải thích tại sao dùng pattern này, làm vậy sau này sẽ có lợi gì.\n  May mắn được vào team anh chị cũng rất tâm lý, rất biết cách dìu dắt sinh viên, lúc đầu bày tỏ ý kiến luôn sợ sai, sợ thiếu nhưng dần dần được nhắc nhở và khơi gợi ý kiến thì mình cũng không ngại bày tỏ quan điểm trong các cuộc họp mặc dù chỉ là một thực tập sinh nhỏ nhoi. Sai thì nói ra mới biết sai mà sửa không thì cứ sai mãi :v Tuy rằng mạnh dạn chia sẻ ý kiến nhưng cũng không quên rằng đừng quá tự tin vào bản thân mà bị mọi người có cái nhìn không đẹp :v\n  Thời điểm này, những thói quen như vậy mình coi trọng hơn là kiến thức mình học được rất nhiều, vì đấy là sẽ là những tiền đề để kiến thức, thái độ của mình xa hơn, sâu hơn trong tương lai. Trên là những vấn đề mình gặp phải và được cải thiện sau vài tháng tham gia vào môi trường doanh nghiệp, hy vọng đâu đó ít nhiều giúp được các bạn chưa đi làm hoặc đi làm mà vẫn những thói quen \u0026ldquo;chưa tốt\u0026rdquo; đó sẽ có lại cái nhìn tốt hơn, rộng hơn.\n","id":0,"section":"posts","summary":"Từ ghế học đường bước vào môi trường doanh nghiệp là một sự thay đổi không hề nhẹ về thói quen, cách làm việc và kể cả kiến thức mình đã được học. Những thứ trong trường chỉ là những thứ rất cơ bản, chưa đủ đáp ứng cho công việc công ty. Mặc dù làm một trang web, mobile application hay một desktop application hoàn chỉnh thì mình cũng đủ sức để làm ra, nhưng vấn đề tại sao vẫn chưa đáp ứng được cho môi trường doanh nghiệp?","tags":["Internship","Experience"],"title":"Ngoài kiến thức thì mình còn học được những gì trong kỳ thực tập?","uri":"https://www.lhsang.me/posts/experience/ngoai-kien-thuc-minh-con-hoc-duoc-gi-khi-thuc-tap/","year":"2020"},{"content":"Ngay thời điểm chuẩn bị để đi phỏng vấn một công ty mới thì mình ngồi hệ thống lại một số câu hỏi mà mình đã được hỏi trong các cuộc phỏng vấn trước đây và những câu hỏi basic nhất mà mình nghĩ nhà tuyển dụng sẽ hỏi thì sẵn tiện mình release luôn bài này khi cần thì coi lại để chuẩn bị tốt nhất trong buổi phỏng vấn. Mình vẫn là sinh viên, đến thời điểm này mình đã đi phỏng vấn ở 2 công ty (tuy nhiên bạn bè mình có mặt ở khá nhiều công ty nên kinh nghiệm phỏng vấn thì mình cũng học được rất nhiều họ) và mình chỉ chia sẻ những thứ thuộc phạm trù của mình nên thiếu sót thì sẽ không tránh khỏi. Nếu có gì hay cần bổ sung mời các bạn comment xuống dưới, mình sẵn sàng tranh luận và tiếp thu :D\nBài này thực tế cần hơn khi đi phỏng vấn ở một số công ty mà họ không quan tâm technical skills của bạn về thứ cụ thể mà họ đang làm, có nghĩa là họ cần một người vững kiến thức nền và sau đó họ sẽ đào tạo lại. Nhưng dù là vị trí cao thấp hay công ty nhỏ lớn gì thì những kiến thức như vậy mình nghĩ chúng ta cần nắm vững, không phải chỉ để trả lời phỏng vấn mà là nó rất cơ bản chúng ta phải biết nếu học ngành này.\nThường thì các công ty có quy trình, chương trình rõ ràng cho intern, fresher thì sẽ chia ra ít nhất 2 vòng với 2 loại câu hỏi (Culture fit - Technical)\nCulture fit interview Đơn giản culture fit là một buổi phỏng vấn về văn hoá và giao tiếp, nơi cả công ty và ứng viên cùng check xem liệu mình và đối phương có phải một “good match” hay không. Phần này sẽ được phòng nhân sự hỏi, có thể được hỏi trong một buổi riêng hoặc hỏi chung ở đầu, sau khi phỏng vấn technical.\nNhà tuyển dụng (NTD) sẽ có một số câu hỏi hoặc đặt một tình huống hỏi mình giải quyết như thế nào. Tất cả những gì chúng ta cần là chuẩn bị một tâm thế chân thành và thoải mái để vượt qua phần này. Sau 2 lần đi phỏng vấn thì rút ra một số câu mình được hỏi sẽ rơi vào những phạm trù sau:\n Teamwork Management Motivation Desired working culture  Chẳng hạn:\n Khi làm việc nhóm em thường gặp những vấn đề gì khó khăn và em đã giải quyết như thế nào? Khi được giao một công việc, bạn sẽ hoàn thành nó như thế nào? Bạn sẽ làm gì khi không thể hoàn thành deadline? Kể một lần sai lầm và bị chỉ trích, bạn phản ứng về điều đó như thế nào? Mức lương mong muốn của em là bao nhiêu cho vị trí này?  Đừng quên chuẩn bị một bài giới thiệu thật hoành tráng (tôi là ai, điểm mạnh điểm yếu như nào, mục tiêu định hướng rõ ràng, \u0026hellip;)\nTechnical Phần này công ty có thể sẽ cho chúng ta test trước 1 bài trắc nghiệm hay code trên một số trang luyện thuật toán để sàng lọc rôì mới gặp phỏng vấn trực tiếp. Với mức độ bài test ở mức độ trung bình, đạt \u0026gt; range(50%, 70%) là pass (tùy). So với kiến thức hỏi trực tiếp thì bài test hỏi rộng hơn do là trắc nghiệm, rộng nhưng không sâu.\nPhỏng vấn technical trực tiếp thì có thể có 1, 2, 3 người, tùy công ty. Kiến thức sẽ rơi vào những môn được học từ năm nhất tới năm 3, có thể hỏi vài câu thực tế liên quan đến vị trí mình apply hoặc liên quan đến công việc cũ của mình (nếu có):\n  Cấu trúc dữ liệu và thuật toán: sẽ hỏi những câu cơ bản và kèm theo một câu hỏi ứng dụng, hoặc so sánh 2 cấu trúc liên quan.\n Mảng, danh sách liên kết (đơn, đôi vòng) Stack \u0026amp; queue Sort, search. Tree (binary, AVL, B-tree) Graph Đệ qui, quy hoạch động Cấu trúc heap, hashtable, hashmap    Lập trình hướng đối tượng:\n 4 tính chất Phân biệt interface vs abstract, class vs object destructor and constructor design pattern (nhóm, biết những loại nào, khi nào dùng, ví dụ trong thực tế)    Cơ sở dữ liệu:\n indexes (cơ chế, các loại index) Delete và Truncate Transaction (các thuộc tính, bài toán thực tế liên quan như 2 user cùng đặt 1 sp nhưng chỉ còn 1 sp) DDL - DML - DCL - TCL. What is DDL and DML?   Câu hỏi ngẫu nhiên về version và điểm mạnh điểm yếu các csdl hay viết một truy vấn để lấy record cao thứ n từ bảng chẳng hạn.    Mạng máy tính:\n TCP vs UDP (so sánh, ứng dụng) HTTP vs HTTPS DNS, DHCP LAN, WAN, MAN    Hệ điều hành:\n Các thuật toán lập lịch Thread vs process Race condition Deadlock vs lock Một số lệnh cơ bản linux Vùng nhớ heap và stack    Kiến thức back-end:\n Các phương thức trong RESTful Các thuật toán cache Cookie, session, localstorage Một số kỹ thuật bảo mật Ít nhiều nên có kiến thức về kiến trúc    Mình chỉ liệt kê ra nội dung NTD sẽ hỏi để tham khảo đương nhiên tương ứng với mỗi câu trả lời của bạn thì NTD sẽ bổ sung và hỏi sâu theo hướng nào, bạn cố gắng tìm hiểu, hệ thống lại và trả lời một cách đầy đủ, thông minh nhất có thể.\nTrên là những phần mình đã được hỏi khi đi phỏng vấn hy vọng ít nhiều cũng giúp được các bạn đạt được vị trí mong muốn ở công ty mình ước ao \u0026lt;3\nGood luck!\n","id":1,"section":"posts","summary":"Ngay thời điểm chuẩn bị để đi phỏng vấn một công ty mới thì mình ngồi hệ thống lại một số câu hỏi mà mình đã được hỏi trong các cuộc phỏng vấn trước đây và những câu hỏi basic nhất mà mình nghĩ nhà tuyển dụng sẽ hỏi thì sẵn tiện mình release luôn bài này khi cần thì coi lại để chuẩn bị tốt nhất trong buổi phỏng vấn.","tags":["Experience","Interview"],"title":"Sinh viên IT \"bị\" hỏi những gì trong những lần đi phỏng vấn vị trí intern, fresher?","uri":"https://www.lhsang.me/posts/experience/intern-fresher-ntd-hoi-gi/","year":"2020"},{"content":"1. What is Nginx?  Nginx ban đầu được tạo ra như một máy chủ web để giải quyết vấn đề C10k (là một vấn đề liên quan đến vấn đề hiệu suất xử lý 10.000 kết nối cùng lúc), nhưng bây giờ với các tính năng mở rộng Nginx cũng được sử dụng phổ biến như một máy chủ proxy (reverse proxy server), HTTP cache hoặc dùng làm cân bằng tải (load balancer). Nginx được thiết kế khả năng chịu tải đồng thời cao và tốc độ cực nhanh. Nginx cấu hình dễ dàng hơn so với Apache httpd Reverse proxy khi có nhiều web services listen trên nhiều port và cần một single public endpoint để định tuyến lại internal requests (cho phép dùng nhiều domain trên port 80).  2. Nginx architecture.  Kiến trúc cơ bản của nginx bao gồm 1 master process và các workers.  master process thực hiện các hoạt đông đặc quyền như đọc config và binding đến các port, sau đó tạo ra các processes con (3 loại process con). cache loader process (load cache) chạy khi khởi động để load bộ đệm trên đĩa vào RAM rồi exit. Nó được lên kế hoạch hoạt động, nên nhu cầu resource rất thấp. cache manager process (quản lý cache) chạy định kỳ và chia các mục từ cache trên đĩa để giữ chúng vừa với kích thước được cấu hình. worker processes xử lý network connections, read và write vào đĩa và liên lạc với các upstream server. Mỗi worker process là một single-thread và chạy độc lập với nhau, chúng liên lạc với nhau thông qua bộ nhớ dùng chung cho dữ liệu cache dùng chung, dữ liệu lưu phiên và các tài nguyên dùng chung khác.    3. Nginx sử dụng single thread   NGINX sử dụng cơ chế asynchronous và event-driven để handle tất cả các connection. Để đạt được điều này nginx hoạt động trên các socket ở chế độ non-blocking và sử dụng một số phương pháp khác như epoll và kqueue. Đây là điểm khác biệt của nginx so với một số server khác, nginx có thể handle đồng thời hàng triệu request và khả năng scale rất tốt.\n  Tuy nhiên vấn đề asynchronous và event-driven vẫn có những problem, nếu nhiều module thứ 3 hoặc chính dev sử dụng blocking thì nginx mất đi thế mạnh vốn có.\n  4. Giải quyết vấn đề blocking.  to be continue\n 5. Thử load balancing dùng nginx.   Mô tả ngắn:\n Chạy web app(flask) trên 2 server (demo dùng 2 port). Dùng nginx để load balancing trên 2 server.    Let\u0026rsquo;s start:\n Điều chỉnh tường lửa allow cho Nginx HTTP (port 80)  $ sudo ufw allow 'Nginx HTTP'   Verify   Demo flask app  from flask import Flask app = Flask(__name__) @app.route('/index') def demo(): return 'hello world'   Config nginx (/etc/nginx/nginx.conf)   upstream demo { server 127.0.0.1:8080; server 127.0.0.1:8000; } server { listen 80; location / { proxy_pass http://demo; } }   Reload service nginx.  $ sudo service nginx reload   Chạy web app trên port 8080 và 8000 giống như đã config  $ flask run --port=8080 $ flask run --port=8000    Thuật toán load balancing mặc định của Nginx là Round robin(các máy chủ sẽ được lựa chọn tuần tự, vòng tròn), chúng ta có thể config lại một thuật toán khác nếu muốn.\n  Kết quả.\n  Lần đầu request được điều hướng tới server với port 8080 Lần request tiếp theo được điều hướng đến server port 8000   References  Nginx Tutorial #1: Basic Concepts Nginx Tutorial An Introduction to NGINX for Developers Inside NGINX: How We Designed for Performance \u0026amp; Scale nginx How to configure load balancing using Nginx Thread Pools in NGINX Boost Performance 9x!  ","id":2,"section":"posts","summary":"1. What is Nginx?  Nginx ban đầu được tạo ra như một máy chủ web để giải quyết vấn đề C10k (là một vấn đề liên quan đến vấn đề hiệu suất xử lý 10.000 kết nối cùng lúc), nhưng bây giờ với các tính năng mở rộng Nginx cũng được sử dụng phổ biến như một máy chủ proxy (reverse proxy server), HTTP cache hoặc dùng làm cân bằng tải (load balancer).","tags":["Technique","Nginx"],"title":"Nginx là gì ? Demo load balancing với nginx","uri":"https://www.lhsang.me/posts/technique/nginx/","year":"2020"},{"content":"gRPC là gì ? Trong thời điểm hiện tại thì JSON REST API vẫn đang rất phổ biến và phổ thông bởi tính dễ sử dụng. Tuy nhiên để nâng cao hiệu năng cho trang web, chúng ta sẽ tìm hiểu vê một framework RPC mới dựa trên protocol buffers và HTTP/2 của Google có tên là gRPC\n  gRPC là một RPC platform được phát triển bởi Google nhằm tối ưu hoá và tăng tốc việc giao tiếp giữa các service với nhau trong kiến trúc microservice.\n  gRPC dùng Protocol Buffers giảm kích thước request và response data, RPC để đơn giản hoá trong việc tạo ra các giao tiếp giữa các service với nhau và dùng HTTP/2 để tăng tốc gửi/nhận HTTP request.\n  1. RPC là gì?\nRPC là từ viết tắc của Remote Procedure Call, nó được xây dựng với ý tưởng là đơn giản hoá việc giao tiếp giữa những service với nhau, thay vì những service giao tiếp với nhau theo kiểu RESTful API thì giờ đơn giản là gọi hàm như những object nói chuyện với nhau thôi, còn việc phân tán các service là chuyện của tương lai không dính liếu đến việc code.\n2. HTTP/2\nHTTP/2 là một phiên bản nâng cấp của HTTP/1.1, HTTP/2 sinh với với mục đích cải thiện tốc độ giao tiếp giữa client/server trên nền tảng Web.\nHTTP/1.1 có nhược điểm là xử lý từng request 1, tức là một request nào đó gởi đến server xử lý xong thì mới gởi request khác đi. Ví dụ khi trang web cần lấy 2 file script.js và style.css với thứ tự tương ứng thì file script.js được trả về xong thì server mới xử lý yêu cầu lấy file style.css. Điều này làm cho thời gian chờ để lấy về tất cả dữ liệu rất tốn thời gian.\nHTTP/2 được ra đời với các mục tiêu: cải thiện tốc dộ giao tiếp, giữ được tính tương thích với HTTP/1và cho phép cả trình duyệt lẫn máy chủ có thể chọn loại giao thức kết nối:\n Compression(nén) of request headers  Mỗi request của HTTP sẽ mang rất nhiều data headers đi và đến cho dù nó giống nhau từ request thứ 2 trở đi. Vì cả client và server đều duy trì một danh sách các headers được sử dụng cho các request trước đó (header frames) nên HTTP/2 sẽ loại bỏ những data headers trùng lặp lại ở những lần request thứ 2 trở đi và nén headers trước khi gửi đi (sử dụng HPACK), sau đó HPACK sẽ tìm kiếm lại header trong header frame để xây dựng lại headers đầy đủ.\n Binary protocol  Browsers sẽ convert text sang binary trước khi gởi qua đường network. Mục đích nhằm giảm kích thước gói tin, tiết kiệm băng thông, giảm chi phí parsing data.\n Request multiplexing over a single TCP connection  HTTP/2 có thể gửi cùng lúc nhiều request đến qua một kết nối TCP(single TCP) và kết quả được trả về bất đồng bộ với nhau (chú ý là hầu hết trình duyệt cũng có giới hạn TCP connections đến một server).\n HTTP/2 Server Push Thêm một cách để tối ưu tốc độ loading của website, thay vì phải có request từ client thì server mới trả resource liên quan về, HTTP/2 sẽ hiểu những resource liên quan và đẩy resource về cho client luôn mà không cần client gửi request.  3. Vậy còn Protocol Buffers ?\nProtocol Buffers gọi tắt là protobuf là ngôn ngữ được phát triển bới Google tạo ra chuẩn sắp xếp mã hóa data với mục đích tạo buffer truyền và nhận giao tiếp một cách linh hoạt, hiệu quả, đơn giản và tăng tốc độ truyền nhận (có vẻ khá giống XML hoặc JSON). Nó lưu trữ dữ liệu có cấu trúc có thể được Serialize hoặc De-Serialized tự động bưởi nhiều ngôn ngữ khác nhau.\nChỉ cần định nghĩa cấu trúc data sử dụng protobuf tạo buffer, sau đó chỉ việc sử dụng hàm thư viện protobuf dễ dàng ghi và đọc cấu trúc data đó đến và từ rất nhiều ngôn ngữ khác nhau. Có thể update lại cấu trúc data nhưng code chương trình sẽ không cần phải thay đổi.\nSo sánh một chút với XML và JSON:\n   Protobuf JSON XML     Không dành cho người đọc vì là binary Con người có thể đọc và chỉnh sửa dễ dành Con người có thể có thể đọc và chỉnh sửa dễ dàng   Khó decode mà không biết schema, định dạng dữ liệu không rõ ràng Có thể phân tích mà không cần biết schema Có thể phân tích cú pháp mà không cần biết schema   Xử lý rất nhanh, nhỏ hơn 3 - 10 lần so với XML hoặc JSON - -    Protobuf rất nhanh nhưng có những tình huống không nên sử dụng nó:\n Khi cần hoặc muốn dữ liệu con người có thể đọc dễ dàng. Dữ liệu từ Service được sử dụng trực tiếp bởi Browser.  Demo gRPC using python gRPC Basics - Python\nReferences  HTTP/2: the difference between HTTP/1.1, benefits and how to use it Protocol Buffers - Developer Guide gRPC Basics - Python Các kỹ sư Eureka đã tối ưu ứng dụng chat sử dụng gRPC như thế nào gRPC official docs [Web] HTTP2 Protocol buffers là gì và những điều căn bản cần biết về nó  ","id":3,"section":"posts","summary":"gRPC là gì ? Trong thời điểm hiện tại thì JSON REST API vẫn đang rất phổ biến và phổ thông bởi tính dễ sử dụng. Tuy nhiên để nâng cao hiệu năng cho trang web, chúng ta sẽ tìm hiểu vê một framework RPC mới dựa trên protocol buffers và HTTP/2 của Google có tên là gRPC\n  gRPC là một RPC platform được phát triển bởi Google nhằm tối ưu hoá và tăng tốc việc giao tiếp giữa các service với nhau trong kiến trúc microservice.","tags":["Technique","RPC","HTTP"],"title":"Tìm hiểu gRPC","uri":"https://www.lhsang.me/posts/technique/grpc/","year":"2020"},{"content":"1. Message-boker ?\n Là chương trình đóng vai trò trung gian lưu trữ cũng như điều phối (valadating, transforming, routing messages) các yêu cầu (message) giữa sender và reciever. Mesage-boker có 2 hình thức giao tiếp cơ bản là:  Publish và Subscribe (Topics) Point-to-Point (Queues)    2. RabbitMQ là gì ?\n  RabbitMQ là một message boker (message-oriented middleware) hay còn gọi là phần mềm quản lý hàng đợi message (thường được gọi là môi giới message hay trình quản lý message). Nói đơn giản đây là phần mềm định nghĩa hàng đợi một ứng dụng khác có thể kết nối tới để bỏ message vào và gửi message dựa trên nó.\nMessage: ở đây có thể chứa nhiều kiểu thông tin. Ví dụ như thông tin về một process/task để khởi động một ứng dụng nào đó (nằm trên một server khác), hoặc có thể là một message chứa text đơn giản.\n  RabbitMQ hỗ trợ nhiều giao thức (AMQP, STOMP, MQTT, HTTP and Websockets), tuy nhiên phương thức phố biến nhất mà rabbitmq sử dụng là AMQP - Advanced Message Queue Protocol\n   Phần mềm quản lý hàng đợi chứa các message cho đến khi ứng dụng nhận đến lấy message.   Một số thuật ngữ trong RabbitMQ  Producer: Bên phát hành message (publisher) Consumer: Bên nhận tin (subscriber) Exchange: Làm nhiệm vụ điều hướng message từ producer đến các queue bên trong do các message không được công khai trực tiếp trong queue. Routing key: Là một khóa mà exchange dùng nó để quyết định cách đưa vào hàng đợi. Routing key có thể hiểu như một địa chỉ của message. Queues: có nhiệm vụ lưu trữ bản tin được gửi lên Connection: Là một kết nối TCP giữa ứng dụng của bạn và RabbitMQ Channel: Một channel là một kết nối ảo bên trong một connection. Khi bạn đẩy đi hoặc nhận các message từ hàng đợi, tất cả phải đi qua channel Binding: Là một kết nối giữa hàng đợi và exchange User: người dùng có thể kết nối đến #RabbitMQ bằng username/password. Mỗi người dùng được cấp quyền như đọc, ghi và cấu hình quyền bên trong một instance. User còn có quyền trên một host ảo. Virtual Host: Cung cấp chức năng tách ứng dụng dùng trên cùng #RabbitMQ. Người dùng khác nhau có quyền hạn khác nhau trên virtual host, hàng đợi hay exchange khác nhau. Chúng chỉ tồn tại trong một virtual host.    3. Tại sao dùng RabbitMQ ?\n  Problems:\n Đối với các hệ thống sử dụng kiến trúc microservice thì việc gọi chéo giữa các service quá nhiều khiến luồng xử lý khá phức tạp. Mức độ trao đổi data giữa các thành phần tăng lên khiến cho việc lập trình trở nên khó khăn (maintain). Khi phát triển làm sao để dev tập trung vào các domain, business logic thay vì các công việc trao đổi ở tầng infrastructure. Với các hệ thống phân tán, khi việc giao tiếp giữa các thành phần đòi hỏi chúng phải biết nhau. Nhưng điều này rắc rối cho việc viết code. Một thành phần phải viết quá nhiều đâm ra rất khó maintain, debug    Sử dụng RabbitMQ:\n Một producer không cần phải biết comsumer. Nó chỉ việc gởi message đến các queue trong message-boker. Consumer chỉ việc đăng ký nhận message từ queue này. Vì producer giao tiếp với consumer trung gian qua message broker nên dù producer và consumer có khác biệt nhau về ngôn ngữ thì giao tiếp vẫn thành công.(Hiện nay rabbitmq đã hỗ trợ rất nhiều ngôn ngữ khác nhau). Một đặc tính của rabbitmq là bất đồng bộ(asynchronous). Producer không thể biết khi nào message đến được consumer hay khi nào message được consumer xử lý xong. Đối với producer, đẩy message đến message broker là xong việc. Consumer sẽ lấy message về khi nó muốn. Đặc tính này có thể được tận dụng để xây dựng các hệ thống lưu trữ và xử lý log.    4. Exchange\nMặc định exchange là chuỗi \u0026ldquo;\u0026quot;. Một exchange có thể có nhiều queue.Exchange có 4 loại: Fanout: Một Fanout exchange sẽ đẩy message đến toàn bộ hàng đợi gắn với nó.  Direct: Một Direct exchange sẽ đẩy message đến hàng đợi dựa theo khóa định tuyến – routing key (do producer khai báo).Ví dụ, nếu hàng đợi gắn với một exchange có binding key là pdfprocess, message được đẩy vào exchange với routing key là pdfprocess sẽ được đưa vào hàng đợi. Topic: Một topic exchange sẽ làm một lá bài (gọi là wildcard) để gắn routing key với một routing pattern khai báo trong bindingConsumer có thể đăng ký những topic mà nó quan tâm. Cú pháp được sử dụng ở đây là * và #. Ví dụ: - booking.* -\u0026gt; Được đăng ký bởi tất cả những key với pattern bắt đầu bằng booking.- booking.# -\u0026gt; Được đăng ký bởi tất cả các key booking hoặc bắt đầu với booking  Headers: Một header exchange sẽ dùng các thuộc tính header của message để định tuyến. Headers Exchange rất giống với Topic Exchange, nhưng nó định tuyến dựa trên các giá trị tiêu đề thay vì các khóa định tuyến. Dead Letter Exchange: Nếu không tìm thấy hàng đợi phù hợp cho tin nhắn, tin nhắn sẽ tự động bị hủy. RabbitMQ cung cấp một tiện ích mở rộng AMQP được gọi là “Dead Letter Exchange” — Cung cấp chức năng để chụp các tin nhắn không thể gửi được.  5. Workflow của RabbitMQ ?\n Producer đẩy message vào exchange. Khi tạo exchange, phải mô tả nó thuộc loại gì. Sau khi exchange nhận message, nó chịu trách nhiệm định tuyến message. Exchange sẽ chịu trách về các thuộc tính của message, ví dụ routing key, phụ thuộc loại exchange. Việc binding phải được tạo từ exchange đến hàng đợi. Trong trường hợp như ảnh, ta sẽ có hai binding đến hai hàng đợi khác nhau từ một exchange. Exchange sẽ định tuyến message vào các hàng đợi dựa trên thuộc tính của của từng message. Các message nằm ở hàng đợi đến khi chúng được xử lý bởi một consumer. Consumer xử lý message.  6. Thử bắn và nhận msg với rabbitmq (python)\n Tạo một service gởi - sender.py: với queue tên \u0026lsquo;demo\u0026rsquo;, exchange \u0026lsquo;logs\u0026rsquo; đẩy msg đến toàn bộ queue (exchange_type='fanout\u0026rsquo;). Bắn msg với routing_keys='key1\u0026rsquo;, nội dung trong body  import pika # using CloudAMQP (https://www.cloudamqp.com/) CLOUDAMQP_URL = 'amqp://vvrzbnja:2xdFFhXnVM2o0QyeU6ynPHrgr9V5C8rK@woodpecker.rmq.cloudamqp.com/vvrzbnja' # establish a connection with RabbitMQ server. params = pika.URLParameters(CLOUDAMQP_URL) connection = pika.BlockingConnection(params) channel = connection.channel() # create queue with name 'demo' channel.queue_declare(queue='demo') channel.exchange_declare(exchange='logs', exchange_type='fanout') # Ready to send a message channel.basic_publish(exchange='logs', routing_key='key1', body='Hello world!') print(\u0026quot; Sent message\u0026quot;) # close connection connection.close()   Service nhận message- receiver.py. Đăng ký nhận msg ở queue \u0026lsquo;demo\u0026rsquo;  import pika CLOUDAMQP_URL = 'amqp://vvrzbnja:2xdFFhXnVM2o0QyeU6ynPHrgr9V5C8rK@woodpecker.rmq.cloudamqp.com/vvrzbnja' # Access the CLODUAMQP_URL environment variable and parse it (fallback to localhost) params = pika.URLParameters(CLOUDAMQP_URL) connection = pika.BlockingConnection(params) channel = connection.channel() # start a channel channel.queue_declare(queue='demo') # Declare a queue def callback(ch, method, properties, body): print(\u0026quot; [x] Received \u0026quot; + str(body)) channel.basic_consume('hello', callback, auto_ack=True) print(' [*] Waiting for messages:') channel.start_consuming() connection.close()   Run  $ python sender.py $ python receiver.py  __References:__RabbitMQ for beginners - What is RabbitMQ? Những điều cần biết về RabbitMQRabbitMQ và Kafka\n","id":4,"section":"posts","summary":"1. Message-boker ?\n Là chương trình đóng vai trò trung gian lưu trữ cũng như điều phối (valadating, transforming, routing messages) các yêu cầu (message) giữa sender và reciever. Mesage-boker có 2 hình thức giao tiếp cơ bản là:  Publish và Subscribe (Topics) Point-to-Point (Queues)    2. RabbitMQ là gì ?\n  RabbitMQ là một message boker (message-oriented middleware) hay còn gọi là phần mềm quản lý hàng đợi message (thường được gọi là môi giới message hay trình quản lý message).","tags":["Technique","Message broker","RabbitMQ"],"title":"RabbitMQ - Demo with python","uri":"https://www.lhsang.me/posts/technique/rabbitmq/","year":"2020"},{"content":"Từ một thằng sinh viên (năm 4) chỉ biết ăn chơi và học, bước ra ngưỡng cửa của xã hội để làm quen, học hỏi và kiếm tiền thì không tránh khỏi những thay đổi về thói quen, công việc,\u0026hellip; Có thể nói đây là lần đầu mình đi thực tập và đi kiếm tiền của thời sinh viên (trước đó có tham gia một startup tuy nhiên sẽ kể ở một câu chuyện khác), vì vậy mình sẽ kể về một ngày làm việc của mình - thực tập sinh công nghệ thông tin, cụ thể là python backend developer tại Teko Viet Nam.\nCông việc của mình là backend develop, ban đầu mình đảm nhiệm service message queue và hệ thống API nhưng cũng khá ít task (do hệ thống hoạt động ổn định đôi lúc cần hotfix, bổ sung hay refactor) và rảnh rỗi nên mình xin làm thêm phần report và connector. Đôi lúc không có task làm thì mình thường ngồi tìm hiều một công nghệ gì đấy rồi note lại (điển hình là các bài viết tại blog này - một số bài mình chưa public), hoặc chạy đi kiếm task, công ty product mà, không nhiều việc và deadline réo như các công ty outsourcing.\nCác công ty IT thường làm việc trễ, công ty mình 9h(nhưng cũng có thể linh hoạt sớm-trễ 1 tí) bắt đầu làm việc, nên tầm 7h30 thức giấc, vệ sinh và ăn sáng, 8h mình bắt đầu lên xe chạy đến công ty. Đến công ty tầm 9h, nhưng thực ra cũng chưa làm việc ngay, lên tới công ty mình thường ăn và uống thêm (công ty có chuẩn bị đồ ăn sáng, đồ ăn uống vặt luôn có và free) đến 9h15 tiến hành daily meeting để các thành viên trong team báo cáo hôm qua làm gì, có khó khăn, đề xuất giải pháp gì cho task đang làm và hôm nay dự định sẽ làm gì. Cũng chỉ là cuộc họp nội bộ nên rất cũng thỏa mái, vui vẻ trao đổi và đùa giỡn 1 tí lấy niềm vui cho ngày làm việc mới chứ không căng thẳng hay nghiêm túc như các cuộc họp khác =))\nDaily meeting xong (tầm 15p) thì về chỗ và tiến hành công việc thôi. Vì công việc có tính liên quan, nên trong quá trình làm việc mình cũng hay qua lại chỗ các anh chị để trao đổi và ngược lại, môi trường làm việc ở đây cũng thoả mái và vui vẻ, không nghiêm túc như các công ty khác, đặc biệt là công ty Nhật. Buổi sáng làm việc tới đúng 12h thì nhân viên được nghỉ đi ăn và nghỉ trưa. Mình thường cùng bạn bè hoặc anh/chị trong team đi ăn quán (công ty thỉnh thoảng cũng có đồ ăn trưa cho nhân viên) tầm 40p trở về công ty và làm vài ván game hay ngủ trưa rồi 13h30 lại tiếp tục công việc.\nBuổi chiều công việc vẫn vậy, tuy nhiên thời gian làm việc buổi chiều dài hơn sáng, nên mình thường làm việc một lúc rồi giải lao ăn uống gì 1 tí, đôi khi cả team tụ họp tại pantry để ăn uống trò chuyện. Hoặc căng thẳng quá thì ra phòng giải trí phóng phi tiêu hay chọc phá đồng nghiệp một tí (công ty mình nhân viên khá trẻ, đa số 9x nên nói chuyện đùa giỡn không vấn đề gì\u0026hellip;) rồi lại bàn tiếp tục.\nLàm việc đến 18h, nếu đói khát thì mình lại ăn =)) rồi ra về, đôi lúc công việc dang dở thì có thể ráng thêm cho xong, hay hết task sớm thì mình cũng vế sớm hơn 1 chút.\n18h về đến nhà tầm 19h, tắm rửa ăn uống, thỉnh thoảng cafe ăn uống với bạn bè rồi về lướt điện thoại máy tính gì rồi đi ngủ. Làm việc cả ngày dù vất vả hay không thì về nhà cũng thấy khá mệt và nhát nên cũng không muốn code hay học hành gì thêm. Hết ngày !!!!!\nMình cảm thấy khá may mắn khi những bước chân đầu cũng không quá khó khăn áp lực nhưng lại học được rất rất nhiều thứ nhờ được làm ở đây, nhìn chung thì môi trường công ty khá thỏa mái, công việc không áp lực, chính sách đãi ngộ mình cũng khá hài lòng. Nhưng cũng chỉ là bước đầu ra đời, cũng chỉ mới thực tập chưa nói lên được gì, cuộc sống và công việc sẽ còn nhiều thay đổi đang chờ mình.\nBàn làm việc của mình.\nLượn một vòng tầng mình đang làm việc lúc 18h15.\n","id":5,"section":"posts","summary":"Từ một thằng sinh viên (năm 4) chỉ biết ăn chơi và học, bước ra ngưỡng cửa của xã hội để làm quen, học hỏi và kiếm tiền thì không tránh khỏi những thay đổi về thói quen, công việc,\u0026hellip; Có thể nói đây là lần đầu mình đi thực tập và đi kiếm tiền của thời sinh viên (trước đó có tham gia một startup tuy nhiên sẽ kể ở một câu chuyện khác), vì vậy mình sẽ kể về một ngày làm việc của mình - thực tập sinh công nghệ thông tin, cụ thể là python backend developer tại Teko Viet Nam.","tags":["Experience","internship"],"title":"Ngày làm việc ở công ty của một thực tập sinh IT","uri":"https://www.lhsang.me/posts/experience/mot-ngay-lam-viec-cua-thuc-tap-sinh-it/","year":"2020"}],"tags":[{"title":"Experience","uri":"https://www.lhsang.me/tags/experience/"},{"title":"HTTP","uri":"https://www.lhsang.me/tags/http/"},{"title":"internship","uri":"https://www.lhsang.me/tags/internship/"},{"title":"Interview","uri":"https://www.lhsang.me/tags/interview/"},{"title":"Message broker","uri":"https://www.lhsang.me/tags/message-broker/"},{"title":"Nginx","uri":"https://www.lhsang.me/tags/nginx/"},{"title":"RabbitMQ","uri":"https://www.lhsang.me/tags/rabbitmq/"},{"title":"RPC","uri":"https://www.lhsang.me/tags/rpc/"},{"title":"Technique","uri":"https://www.lhsang.me/tags/technique/"}]}